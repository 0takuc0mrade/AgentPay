// SPDX-License-Identifier: MIT
pragma solidity ^0.8.28;

import "@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/cryptography/ECDSA.sol";
import "@openzeppelin/contracts/utils/cryptography/MessageHashUtils.sol";

// ----------------------------------------------------------------------------
// INTERFACE: The "Remote Control" for USDC (EIP-3009)
// ----------------------------------------------------------------------------
interface IERC20Permit {
    function transferWithAuthorization(
        address from, address to, uint256 value, uint256 validAfter, uint256 validBefore, bytes32 nonce, uint8 v, bytes32 r, bytes32 s
    ) external;
}

// ----------------------------------------------------------------------------
// CONTRACT: The AgentPay Protocol
// ----------------------------------------------------------------------------
contract AgentProtocol is ERC721URIStorage, Ownable {
    using ECDSA for bytes32;

    struct PaymentParams {
        address payer;
        uint256 amount;
        bytes32 paymentNonce; // The random unique ID generated by the Client
        uint256 validAfter;
        uint256 validBefore;
        uint8 v;
        bytes32 r;
        bytes32 s;
    }

    // --- CONFIGURATION ---
    uint256 private _nextTokenId;
    address public immutable usdcToken;

    // --- LEVEL 1: IDENTITY ---
    mapping(uint256 => address) public agentWorkers;

    // --- LEVEL 2: REPUTATION ---
    // FIX APPLIED: We removed 'agentNonces' (security critical)
    // and replaced it with 'agentTxCount' (just for analytics/stats).
    mapping(uint256 => uint256) public agentTxCount;

    // Updated event to include paymentNonce for easier tracking
    event FeedbackLogged(uint256 indexed agentId, uint8 score, address indexed reviewer, bytes32 indexed paymentNonce);

    // --- LEVEL 3: DISCOVERY ---
    struct Service {
        string name;
        uint256 price;
        bool active;
    }
    mapping(uint256 => Service[]) public agentServices;

    constructor(address _usdcAddress) ERC721("AgentAuth", "AGENT") Ownable(msg.sender) {
        usdcToken = _usdcAddress;
    }

    // ========================================================================
    // IDENTITY & DISCOVERY LOGIC (Standard)
    // ========================================================================

    function registerAgent(address creator, string memory metadataURI) public returns (uint256) {
        uint256 tokenId = _nextTokenId++;
        _safeMint(creator, tokenId);
        _setTokenURI(tokenId, metadataURI);
        return tokenId;
    }

    function setWorkerAddress(uint256 agentId, address worker) public {
        require(ownerOf(agentId) == msg.sender, "Caller is not the agent owner");
        agentWorkers[agentId] = worker;
    }

    function setAgentURI(uint256 tokenId, string memory newURI) public {
        require(ownerOf(tokenId) == msg.sender, "Caller is not the agent owner");
        _setTokenURI(tokenId, newURI);
    }

    function addService(uint256 agentId, string memory name, uint256 price) public {
        require(ownerOf(agentId) == msg.sender, "Not the owner");
        agentServices[agentId].push(Service(name, price, true));
    }

    function getServices(uint256 agentId) public view returns (Service[] memory) {
        return agentServices[agentId];
    }

    // ========================================================================
    // ATOMIC SETTLEMENT ENGINE
    // ========================================================================

    function settleAndLog(
        PaymentParams calldata payData,
        uint256 agentId,
        uint8 score,
        bytes memory repSignature
    ) public {
        require(score <= 5, "Invalid score");

        // 1. VERIFY WORKER EXISTENCE
        address agentWallet = agentWorkers[agentId];
        require(agentWallet != address(0), "Agent worker not set");

        // 2. EXECUTE PAYMENT (EIP-3009)
        // We rely on the USDC contract to check if 'payData.paymentNonce' was used before.
        // If it was used, this line REVERTS. This is our free security check.
        IERC20Permit(usdcToken).transferWithAuthorization(
            payData.payer,
            agentWallet,
            payData.amount,
            payData.validAfter,
            payData.validBefore,
            payData.paymentNonce,
            payData.v,
            payData.r,
            payData.s
        );

        // 3. VERIFY REPUTATION SIGNATURE (THE FIX)
        // Instead of reading 'agentNonces[id]' from state (expensive),
        // we use the 'payData.paymentNonce' (already provided) in the hash.
        // This cryptographically binds the Review to THIS specific Payment.
        bytes32 hash = keccak256(abi.encodePacked(agentId, score, payData.paymentNonce));

        bytes32 ethSignedHash = MessageHashUtils.toEthSignedMessageHash(hash);
        address signer = ECDSA.recover(ethSignedHash, repSignature);

        require(signer == agentWallet, "Agent did not authorize this review");

        // 4. FINALIZE
        // We just increment a stat counter (not critical for security anymore)
        agentTxCount[agentId]++;

        emit FeedbackLogged(agentId, score, payData.payer, payData.paymentNonce);
    }
}