// SPDX-License-Identifier: MIT
pragma solidity ^0.8.28;

import "@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/cryptography/ECDSA.sol";
import "@openzeppelin/contracts/utils/cryptography/MessageHashUtils.sol";

// ----------------------------------------------------------------------------
// INTERFACE: The "Remote Control" for USDC (EIP-3009)
// ----------------------------------------------------------------------------
interface IERC20Permit {
    function transferWithAuthorization(
        address from, address to, uint256 value, uint256 validAfter, uint256 validBefore, bytes32 nonce, uint8 v, bytes32 r, bytes32 s
    ) external;
}

// ----------------------------------------------------------------------------
// CONTRACT: The AgentPay Protocol (ERC-8004 Compatible + Atomic Settlement)
// ----------------------------------------------------------------------------
contract AgentProtocol is ERC721URIStorage, Ownable {
    using ECDSA for bytes32;

    struct PaymentParams {
        address payer;
        uint256 amount;
        bytes32 paymentNonce; // Random unique ID generated by Client
        uint256 validAfter;
        uint256 validBefore;
        uint8 v;
        bytes32 r;
        bytes32 s;
    }

    // --- CONFIGURATION ---
    uint256 private _nextTokenId;
    address public immutable usdcToken;

    // --- LEVEL 1: IDENTITY ---
    mapping(uint256 => address) public agentWorkers;

    // --- LEVEL 2: REPUTATION ---
    mapping(uint256 => uint256) public agentTxCount;

    // COMPLIANCE FIX: Updated event to match ERC-8004 Standard
    // This allows standard indexers to read your reputation logs.
    event NewFeedback(
        uint256 indexed agentId,
        address indexed clientAddress,
        uint8 score,
        bytes32 indexed tag1, // "x402-verified"
        bytes32 tag2,         // e.g. "weather-service"
        string fileuri,       // IPFS link to full details
        bytes32 paymentNonce  // We use the filehash slot for the payment nonce
    );

    event AgentRegistered(uint256 indexed agentId, address indexed creator, string metadataURI);

    // --- LEVEL 3: DISCOVERY ---
    struct Service {
        string name;
        uint256 price;
        bool active;
    }
    mapping(uint256 => Service[]) public agentServices;

    constructor(address _usdcAddress) ERC721("AgentAuth", "AGENT") Ownable(msg.sender) {
        usdcToken = _usdcAddress;
    }

    // ========================================================================
    // IDENTITY & DISCOVERY LOGIC
    // ========================================================================

    function registerAgent(address creator, string memory metadataURI) public returns (uint256) {
        uint256 tokenId = _nextTokenId++;
        _safeMint(creator, tokenId);
        _setTokenURI(tokenId, metadataURI);
        emit AgentRegistered(tokenId, creator, metadataURI);
        return tokenId;
    }

    function setWorkerAddress(uint256 agentId, address worker) public {
        require(ownerOf(agentId) == msg.sender, "Caller is not the agent owner");
        agentWorkers[agentId] = worker;
    }

    function setAgentURI(uint256 tokenId, string memory newURI) public {
        require(ownerOf(tokenId) == msg.sender, "Caller is not the agent owner");
        _setTokenURI(tokenId, newURI);
    }

    function addService(uint256 agentId, string memory name, uint256 price) public {
        require(ownerOf(agentId) == msg.sender, "Not the owner");
        agentServices[agentId].push(Service(name, price, true));
    }

    function getServices(uint256 agentId) public view returns (Service[] memory) {
        return agentServices[agentId];
    }

    // ========================================================================
    // ATOMIC SETTLEMENT ENGINE
    // ========================================================================

    function settleAndLog(
        PaymentParams calldata payData,
        uint256 agentId,
        uint8 score,
        bytes memory repSignature,
        // New Optional Params for Protocol Compliance
        bytes32 tag2,
        string memory fileuri
    ) public {
        require(score <= 100, "Invalid score"); // Protocol uses 0-100 scale

        // 1. VERIFY WORKER
        address agentWallet = agentWorkers[agentId];
        require(agentWallet != address(0), "Agent worker not set");

        // 2. EXECUTE PAYMENT (EIP-3009)
        // If this fails (nonce reused, no money), entire transaction reverts.
        IERC20Permit(usdcToken).transferWithAuthorization(
            payData.payer,
            agentWallet,
            payData.amount,
            payData.validAfter,
            payData.validBefore,
            payData.paymentNonce,
            payData.v,
            payData.r,
            payData.s
        );

        // 3. VERIFY REPUTATION SIGNATURE
        // Hash: AgentID + Score + PaymentNonce
        bytes32 hash = keccak256(abi.encodePacked(agentId, score, payData.paymentNonce));

        bytes32 ethSignedHash = MessageHashUtils.toEthSignedMessageHash(hash);
        address signer = ECDSA.recover(ethSignedHash, repSignature);

        require(signer == agentWallet, "Agent did not authorize this review");

        // 4. FINALIZE & EMIT STANDARD EVENT
        agentTxCount[agentId]++;

        // We emit 'NewFeedback' so ERC-8004 indexers can read this.
        // tag1 is hardcoded to "x402-verified" to prove it was a paid transaction.
        emit NewFeedback(
            agentId,
            payData.payer,
            score,
            keccak256("x402-verified"), // Tag 1
            tag2,                       // Tag 2 (Custom category)
            fileuri,                    // IPFS link
            payData.paymentNonce        // Link to payment
        );
    }
}